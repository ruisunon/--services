
# ==================>> EmployeeRepository <<========================
List.findByDepartmentId=SELECT * FROM employees WHERE department_id = :departmentId				
List<Employee>.findByManagerId=SELECT * FROM employees WHERE manager_id = :managerId				
Set<EmployeeAssignedProject>.findByManagerIdAndProjectId=SELECT DISTINCT e.employee_id AS employeeId, e.first_name AS firstName, e.last_name AS lastName, FALSE AS verif FROM employees e LEFT JOIN assignments a ON e.employee_id = a.employee_id WHERE e.manager_id = :managerId AND e.employee_id NOT IN( SELECT DISTINCT e.employee_id FROM employees e INNER JOIN assignments a ON e.employee_id = a.employee_id WHERE e.manager_id = :managerId AND a.project_id = :projectId ) 
#Set<EmployeeAssignedProject>.findByManagerIdAndProjectId=SELECT DISTINCT e.employee_id AS employeeId, e.first_name AS firstName, e.last_name AS lastName, TRUE AS verif FROM employees e INNER JOIN assignments a ON e.employee_id = a.employee_id WHERE e.manager_id = :managerId AND a.project_id = :projectId UNION SELECT DISTINCT e.employee_id AS employeeId, e.first_name AS firstName, e.last_name AS lastName, FALSE AS verif FROM employees e LEFT JOIN assignments a ON e.employee_id = a.employee_id WHERE e.manager_id = :managerId AND e.employee_id NOT IN( SELECT DISTINCT e.employee_id FROM employees e INNER JOIN assignments a ON e.employee_id = a.employee_id WHERE e.manager_id = :managerId AND a.project_id = :projectId )
Set<Employee>.findAllManagers=SELECT DISTINCT m.* FROM employees e INNER JOIN employees m ON e.manager_id = m.employee_id


# ==================>> AssignmentRepository <<========================
Optional.findByCompositeIds=SELECT * FROM assignments WHERE employee_id = :employeeId AND project_id = :projectId AND commit_date = :commitDate
List.findByEmployeeId=SELECT DISTINCT p.project_id AS projectId, p.title AS title, COALESCE(p.start_date, '-') AS startDate, COALESCE(p.end_date, '-') AS endDate, p.status AS status FROM employees e INNER JOIN assignments a ON e.employee_id = a.employee_id INNER JOIN projects p ON a.project_id = p.project_id WHERE a.employee_id = :employeeId						
List.findByProjectId=SELECT DISTINCT e.employee_id AS employeeId, e.first_name AS firstName, e.last_name AS lastName, a.project_id AS projectId, a.commit_date AS commitDate, COALESCE(a.commit_emp_desc, '-') AS commitEmpDesc, COALESCE(a.commit_mgr_desc, '-') AS commitMgrDesc FROM assignments a INNER JOIN employees e ON a.employee_id = e.employee_id WHERE a.project_id = :projectId AND (commit_emp_desc IS NOT NULL OR LOWER(commit_mgr_desc) != 'init') ORDER BY a.commit_date DESC											
ProjectCommit.findByEmployeeIdAndProjectIdAndCommitDate=SELECT DISTINCT e.employee_id AS employeeId, e.first_name AS firstName, e.last_name AS lastName, a.project_id AS projectId, a.commit_date AS commitDate, COALESCE(a.commit_emp_desc, '-') AS commitEmpDesc, COALESCE(a.commit_mgr_desc, '-') AS commitMgrDesc FROM assignments a INNER JOIN employees e ON a.employee_id = e.employee_id WHERE e.employee_id = :employeeId AND a.project_id = :projectId AND a.commit_date = :commitDate											
List.findByEmployeeIdAndProjectId=SELECT DISTINCT e.first_name AS firstName, e.last_name AS lastName, a.project_id AS projectId, a.commit_date AS commitDate, COALESCE(a.commit_emp_desc, '-') AS commitEmpDesc, COALESCE(a.commit_mgr_desc, '-') AS commitMgrDesc FROM assignments a INNER JOIN employees e ON a.employee_id = e.employee_id WHERE a.employee_id = :employeeId AND a.project_id = :projectId AND (commit_emp_desc IS NOT NULL OR LOWER(commit_mgr_desc) != 'init') ORDER BY a.commit_date DESC											
ProjectCommitInfoDTO.findByUsernameAndProjectId=SELECT DISTINCT u.username AS username, p.project_id AS projectId, p.title AS title FROM user_credentials u INNER JOIN employees e ON u.employee_id = e.employee_id INNER JOIN assignments a ON e.employee_id = a.employee_id INNER JOIN projects p ON a.project_id = p.project_id WHERE u.username = :username AND p.project_id = :projectId		
List<ManagerProjectData>.findByEmployeeId=SELECT DISTINCT p.project_id AS projectId, p.title AS title, COALESCE(p.start_date, '-') AS startDate, COALESCE(p.end_date, '-') AS endDate, p.status AS status FROM employees e INNER JOIN employees m ON e.manager_id = m.employee_id INNER JOIN assignments a ON e.employee_id = a.employee_id INNER JOIN projects p ON a.project_id = p.project_id WHERE m.employee_id = :employeeId				
void.deleteByProjectId=DELETE FROM assignments WHERE project_id = :projectId
#Set<Assignment>.findByProjectIdAndCommitDateFromAndCommitDateTo=SELECT * FROM assignments WHERE project_id = :projectId AND commit_date >= :commitDateFrom AND commit_date < :commitDateTo
Set<ProjectCommit>.findByProjectIdAndCommitDateFromAndCommitDateTo=SELECT DISTINCT a.employee_id AS employeeId, e.first_name AS firstName, e.last_name AS lastName, a.project_id AS projectId, a.commit_date AS commitDate, a.commit_emp_desc AS commitEmpDesc, a.commit_mgr_desc AS commitMgrDesc FROM assignments a INNER JOIN employees e ON a.employee_id = e.employee_id WHERE project_id = :projectId AND commit_date >= :commitDateFrom AND commit_date < :commitDateTo


# ==================>> UserCredentialRepository <<========================
Optional.findByUsername=SELECT * FROM user_credentials WHERE LOWER(username) = :username


# ==================>> ProjectRepository <<========================
List.getProjectStatus=SELECT status AS label, COUNT(*) AS value FROM projects GROUP BY status